# Блок 6.4: Статистика по источникам трафика

## Цель

Реализовать аналитику по источникам трафика: общая статистика, сравнение источников, динамика по времени.

## Задачи

### 1. Общая статистика по источникам

**Файл: `database/queries.py`**

```python
async def get_traffic_source_stats(
    session: AsyncSession,
    start_date=None,
    end_date=None
) -> dict:
    """
    Статистика по источникам
    
    Для каждого источника:
    - users: количество пользователей
    - new_users: новых пользователей
    - revenue: доход
    - deposits: депозиты
    - applications: заявки
    - average_ltv: средний LTV
    - conversion_rate: конверсия
    """
    # Основной запрос с агрегацией
    query = select(
        User.traffic_source,
        func.count(func.distinct(User.user_id)).label('users'),
        func.count(func.distinct(case((Transaction.type == TRANSACTION_DEPOSIT, Transaction.user_id)))).label('users_with_deposit'),
        func.count(func.distinct(Application.user_id)).label('users_with_application'),
        func.sum(case((Transaction.type == TRANSACTION_DEPOSIT, Transaction.amount))).label('revenue'),
        func.count(case((Transaction.type == TRANSACTION_DEPOSIT, Transaction.id))).label('deposits'),
        func.count(Application.id).label('applications')
    ).outerjoin(
        Transaction, User.user_id == Transaction.user_id
    ).outerjoin(
        Application, User.user_id == Application.user_id
    )
    
    if start_date:
        query = query.where(User.created_at >= start_date)
    if end_date:
        query = query.where(User.created_at <= end_date)
    
    query = query.group_by(User.traffic_source)
    result = await session.execute(query)
    
    stats_data = {}
    for row in result.all():
        source = row.traffic_source or 'unknown'
        users = row.users or 0
        users_with_deposit = row.users_with_deposit or 0
        users_with_application = row.users_with_application or 0
        revenue = row.revenue or 0
        deposits = row.deposits or 0
        applications = row.applications or 0
        
        average_ltv = revenue / users if users > 0 else 0.0
        conversion_rate = (users_with_application / users * 100.0) if users > 0 else 0.0
        
        stats_data[source] = {
            "users": users,
            "new_users": users,  # Можно уточнить логику
            "revenue": revenue,
            "deposits": deposits,
            "applications": applications,
            "average_ltv": average_ltv,
            "conversion_rate": conversion_rate
        }
    
    return stats_data

async def get_top_sources_by_revenue(
    session: AsyncSession,
    limit=10,
    start_date=None,
    end_date=None
) -> list:
    """Топ источников по доходу"""
    stats = await get_traffic_source_stats(session, start_date, end_date)
    
    sorted_sources = sorted(
        stats.items(),
        key=lambda x: x[1]['revenue'],
        reverse=True
    )
    
    return [
        {
            "source": source,
            "revenue": data['revenue'],
            "users": data['users'],
            "average_ltv": data['average_ltv']
        }
        for source, data in sorted_sources[:limit]
    ]

async def get_top_sources_by_users(
    session: AsyncSession,
    limit=10,
    start_date=None,
    end_date=None
) -> list:
    """Топ источников по количеству пользователей"""
    stats = await get_traffic_source_stats(session, start_date, end_date)
    
    sorted_sources = sorted(
        stats.items(),
        key=lambda x: x[1]['users'],
        reverse=True
    )
    
    return [
        {
            "source": source,
            "users": data['users'],
            "revenue": data['revenue'],
            "conversion_rate": data['conversion_rate']
        }
        for source, data in sorted_sources[:limit]
    ]

async def get_top_sources_by_conversion(
    session: AsyncSession,
    limit=10,
    start_date=None,
    end_date=None
) -> list:
    """Топ источников по конверсии"""
    stats = await get_traffic_source_stats(session, start_date, end_date)
    
    # Фильтруем источники с минимумом пользователей (например, 10)
    filtered_stats = {
        k: v for k, v in stats.items()
        if v['users'] >= 10
    }
    
    sorted_sources = sorted(
        filtered_stats.items(),
        key=lambda x: x[1]['conversion_rate'],
        reverse=True
    )
    
    return [
        {
            "source": source,
            "conversion_rate": data['conversion_rate'],
            "users": data['users'],
            "applications": data['applications']
        }
        for source, data in sorted_sources[:limit]
    ]

async def get_campaign_stats(
    session: AsyncSession,
    start_date=None,
    end_date=None
) -> dict:
    """Статистика по кампаниям"""
    query = select(
        User.traffic_campaign,
        func.count(func.distinct(User.user_id)).label('users'),
        func.sum(case((Transaction.type == TRANSACTION_DEPOSIT, Transaction.amount))).label('revenue'),
        func.count(Application.id).label('applications')
    ).outerjoin(
        Transaction, User.user_id == Transaction.user_id
    ).outerjoin(
        Application, User.user_id == Application.user_id
    )
    
    if start_date:
        query = query.where(User.created_at >= start_date)
    if end_date:
        query = query.where(User.created_at <= end_date)
    
    query = query.group_by(User.traffic_campaign)
    result = await session.execute(query)
    
    campaign_data = {}
    for row in result.all():
        campaign = row.traffic_campaign or 'unknown'
        campaign_data[campaign] = {
            "users": row.users or 0,
            "revenue": row.revenue or 0,
            "applications": row.applications or 0
        }
    
    return campaign_data
```

### 2. Временная динамика

**Файл: `database/queries.py`**

```python
async def get_source_dynamics(
    session: AsyncSession,
    source: str,
    days: int = 30
) -> list[dict]:
    """
    Динамика показателей источника по дням
    
    Возвращает список словарей с данными по каждому дню
    """
    from datetime import datetime, timedelta
    
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=days)
    
    dynamics = []
    
    for day_offset in range(days):
        day_start = start_date + timedelta(days=day_offset)
        day_end = day_start + timedelta(days=1)
        
        # Пользователи за день
        users_query = select(func.count(User.user_id)).where(
            User.traffic_source == source,
            User.created_at >= day_start,
            User.created_at < day_end
        )
        users_result = await session.execute(users_query)
        users = users_result.scalar() or 0
        
        # Доход за день
        revenue_query = select(func.sum(Transaction.amount)).join(
            User, Transaction.user_id == User.user_id
        ).where(
            User.traffic_source == source,
            Transaction.type == TRANSACTION_DEPOSIT,
            Transaction.created_at >= day_start,
            Transaction.created_at < day_end
        )
        revenue_result = await session.execute(revenue_query)
        revenue = revenue_result.scalar() or 0
        
        # Заявки за день
        applications_query = select(func.count(Application.id)).join(
            User, Application.user_id == User.user_id
        ).where(
            User.traffic_source == source,
            Application.created_at >= day_start,
            Application.created_at < day_end
        )
        applications_result = await session.execute(applications_query)
        applications = applications_result.scalar() or 0
        
        dynamics.append({
            "date": day_start.strftime('%Y-%m-%d'),
            "users": users,
            "revenue": revenue,
            "applications": applications
        })
    
    return dynamics

async def compare_sources(
    session: AsyncSession,
    sources: list[str],
    start_date=None,
    end_date=None
) -> dict:
    """
    Сравнение источников
    
    Возвращает сравнительную статистику для указанных источников
    """
    comparison = {}
    
    for source in sources:
        stats = await get_traffic_source_stats(session, start_date, end_date)
        source_stats = stats.get(source, {})
        
        comparison[source] = {
            "users": source_stats.get('users', 0),
            "revenue": source_stats.get('revenue', 0),
            "applications": source_stats.get('applications', 0),
            "average_ltv": source_stats.get('average_ltv', 0.0),
            "conversion_rate": source_stats.get('conversion_rate', 0.0)
        }
    
    return comparison
```

### 3. Функции агрегации

**Файл: `utils/statistics.py`**

```python
async def get_traffic_stats(
    session: AsyncSession,
    period: str = StatisticsPeriod.ALL_TIME
) -> dict:
    """Получить статистику по источникам трафика"""
    start_date, end_date = get_date_range(period)
    
    source_stats = await get_traffic_source_stats(session, start_date, end_date)
    top_by_revenue = await get_top_sources_by_revenue(session, limit=10, start_date=start_date, end_date=end_date)
    top_by_users = await get_top_sources_by_users(session, limit=10, start_date=start_date, end_date=end_date)
    top_by_conversion = await get_top_sources_by_conversion(session, limit=10, start_date=start_date, end_date=end_date)
    campaign_stats = await get_campaign_stats(session, start_date=start_date, end_date=end_date)
    
    return {
        "by_source": source_stats,
        "top_by_revenue": top_by_revenue,
        "top_by_users": top_by_users,
        "top_by_conversion": top_by_conversion,
        "by_campaign": campaign_stats,
        "period": period
    }
```

## Тестирование

1. Тестирование запросов по источникам
2. Тестирование динамики по дням
3. Тестирование сравнения источников
4. Проверка производительности запросов

## Оценка времени

**3-4 часа**

# Блок 6.3: Маркетинговые показатели

## Цель

Реализовать расчет маркетинговых метрик: конверсия, LTV (Lifetime Value), CAC (Cost per Acquisition), ROI и Retention rate.

## Задачи

### 1. Конверсия

**Файл: `utils/marketing.py`** (новый)

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, case
from database.models import User, Transaction, Application
from database.queries import get_total_users, get_total_applications
from config import TRANSACTION_DEPOSIT, STATUS_COMPLETED

async def get_conversion_funnel(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """
    Конверсия по этапам воронки
    
    Возвращает:
    - visitors: количество уникальных посетителей (пользователей)
    - registered: зарегистрировались
    - first_deposit: сделали первый депозит
    - first_application: создали первую заявку
    - completed_application: завершили заявку
    - conversion_rates: процент конверсии на каждом этапе
    """
    # Все пользователи за период
    visitors_query = select(func.count(User.user_id))
    if start_date:
        visitors_query = visitors_query.where(User.created_at >= start_date)
    if end_date:
        visitors_query = visitors_query.where(User.created_at <= end_date)
    visitors_result = await session.execute(visitors_query)
    visitors = visitors_result.scalar() or 0
    
    # Пользователи с депозитами
    deposits_query = select(func.count(func.distinct(Transaction.user_id))).where(
        Transaction.type == TRANSACTION_DEPOSIT
    )
    if start_date:
        deposits_query = deposits_query.where(Transaction.created_at >= start_date)
    if end_date:
        deposits_query = deposits_query.where(Transaction.created_at <= end_date)
    deposits_result = await session.execute(deposits_query)
    first_deposit = deposits_result.scalar() or 0
    
    # Пользователи с заявками
    applications_query = select(func.count(func.distinct(Application.user_id)))
    if start_date:
        applications_query = applications_query.where(Application.created_at >= start_date)
    if end_date:
        applications_query = applications_query.where(Application.created_at <= end_date)
    applications_result = await session.execute(applications_query)
    first_application = applications_result.scalar() or 0
    
    # Пользователи с завершенными заявками
    completed_query = select(func.count(func.distinct(Application.user_id))).where(
        Application.status == STATUS_COMPLETED
    )
    if start_date:
        completed_query = completed_query.where(Application.created_at >= start_date)
    if end_date:
        completed_query = completed_query.where(Application.created_at <= end_date)
    completed_result = await session.execute(completed_query)
    completed_application = completed_result.scalar() or 0
    
    # Расчет конверсий
    conversion_rates = {}
    if visitors > 0:
        conversion_rates['to_deposit'] = (first_deposit / visitors) * 100.0
        conversion_rates['to_application'] = (first_application / visitors) * 100.0
        conversion_rates['to_completed'] = (completed_application / visitors) * 100.0
    else:
        conversion_rates = {'to_deposit': 0.0, 'to_application': 0.0, 'to_completed': 0.0}
    
    return {
        "visitors": visitors,
        "registered": visitors,  # В нашем случае регистрация = посещение
        "first_deposit": first_deposit,
        "first_application": first_application,
        "completed_application": completed_application,
        "conversion_rates": conversion_rates
    }

async def get_conversion_by_source(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """
    Конверсия по источникам трафика
    
    Для каждого источника:
    - users: количество пользователей
    - deposits: количество депозитов
    - applications: количество заявок
    - conversion_to_deposit: %
    - conversion_to_application: %
    """
    query = select(
        User.traffic_source,
        func.count(func.distinct(User.user_id)).label('users'),
        func.count(func.distinct(case((Transaction.type == TRANSACTION_DEPOSIT, Transaction.user_id)))).label('users_with_deposit'),
        func.count(func.distinct(Application.user_id)).label('users_with_application')
    ).outerjoin(
        Transaction, User.user_id == Transaction.user_id
    ).outerjoin(
        Application, User.user_id == Application.user_id
    )
    
    if start_date:
        query = query.where(User.created_at >= start_date)
    if end_date:
        query = query.where(User.created_at <= end_date)
    
    query = query.group_by(User.traffic_source)
    result = await session.execute(query)
    
    conversion_data = {}
    for row in result.all():
        source = row.traffic_source or 'unknown'
        users = row.users or 0
        users_with_deposit = row.users_with_deposit or 0
        users_with_application = row.users_with_application or 0
        
        conversion_to_deposit = (users_with_deposit / users * 100.0) if users > 0 else 0.0
        conversion_to_application = (users_with_application / users * 100.0) if users > 0 else 0.0
        
        conversion_data[source] = {
            "users": users,
            "deposits": users_with_deposit,
            "applications": users_with_application,
            "conversion_to_deposit": conversion_to_deposit,
            "conversion_to_application": conversion_to_application
        }
    
    return conversion_data

async def get_conversion_by_campaign(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """Конверсия по кампаниям"""
    # Аналогично get_conversion_by_source, но группировка по traffic_campaign
    pass
```

### 2. LTV (Lifetime Value)

**Файл: `utils/marketing.py`**

```python
async def get_average_ltv(session: AsyncSession, start_date=None, end_date=None) -> float:
    """
    Средний LTV пользователя
    
    Средний доход от пользователя за все время
    Сумма всех депозитов пользователя минус возвраты
    """
    # Фильтр по дате регистрации пользователей
    users_query = select(User.user_id)
    if start_date:
        users_query = users_query.where(User.created_at >= start_date)
    if end_date:
        users_query = users_query.where(User.created_at <= end_date)
    
    # Сумма депозитов по пользователям
    ltv_query = select(
        func.avg(
            select(func.sum(Transaction.amount))
            .where(Transaction.type == TRANSACTION_DEPOSIT)
            .where(Transaction.user_id == User.user_id)
            .scalar_subquery()
        )
    )
    
    result = await session.execute(ltv_query)
    return result.scalar() or 0.0

async def get_ltv_by_source(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """
    LTV по источникам трафика
    
    Для каждого источника:
    - average_ltv: средний LTV
    - median_ltv: медианный LTV
    - total_revenue: общий доход
    - user_count: количество пользователей
    """
    # Подзапрос для LTV каждого пользователя
    user_ltv_subquery = select(
        User.user_id,
        User.traffic_source,
        func.sum(Transaction.amount).label('user_ltv')
    ).join(
        Transaction, User.user_id == Transaction.user_id
    ).where(
        Transaction.type == TRANSACTION_DEPOSIT
    ).group_by(
        User.user_id, User.traffic_source
    ).subquery()
    
    # Агрегация по источникам
    query = select(
        user_ltv_subquery.c.traffic_source,
        func.count(user_ltv_subquery.c.user_id).label('user_count'),
        func.sum(user_ltv_subquery.c.user_ltv).label('total_revenue'),
        func.avg(user_ltv_subquery.c.user_ltv).label('average_ltv'),
        func.median(user_ltv_subquery.c.user_ltv).label('median_ltv')  # Может не работать в SQLite
    ).group_by(
        user_ltv_subquery.c.traffic_source
    )
    
    if start_date:
        # Добавить фильтр по дате регистрации
        pass
    
    result = await session.execute(query)
    
    ltv_data = {}
    for row in result.all():
        source = row.traffic_source or 'unknown'
        ltv_data[source] = {
            "average_ltv": row.average_ltv or 0.0,
            "median_ltv": row.median_ltv or 0.0,
            "total_revenue": row.total_revenue or 0,
            "user_count": row.user_count or 0
        }
    
    return ltv_data

async def get_ltv_by_segment(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """
    LTV по сегментам
    
    Сегменты:
    - new_users: новые пользователи (< 7 дней)
    - active_users: активные (7-30 дней)
    - returning_users: возвращающиеся (> 30 дней)
    """
    from datetime import timedelta
    
    now = datetime.utcnow()
    new_cutoff = now - timedelta(days=7)
    active_cutoff = now - timedelta(days=30)
    
    # LTV для новых пользователей
    new_users_query = select(
        func.avg(
            select(func.sum(Transaction.amount))
            .where(Transaction.type == TRANSACTION_DEPOSIT)
            .where(Transaction.user_id == User.user_id)
            .scalar_subquery()
        )
    ).where(
        User.created_at >= new_cutoff
    )
    if start_date:
        new_users_query = new_users_query.where(User.created_at >= start_date)
    if end_date:
        new_users_query = new_users_query.where(User.created_at <= end_date)
    
    new_result = await session.execute(new_users_query)
    new_ltv = new_result.scalar() or 0.0
    
    # LTV для активных пользователей
    active_users_query = select(
        func.avg(
            select(func.sum(Transaction.amount))
            .where(Transaction.type == TRANSACTION_DEPOSIT)
            .where(Transaction.user_id == User.user_id)
            .scalar_subquery()
        )
    ).where(
        User.created_at >= active_cutoff,
        User.created_at < new_cutoff
    )
    if start_date:
        active_users_query = active_users_query.where(User.created_at >= start_date)
    if end_date:
        active_users_query = active_users_query.where(User.created_at <= end_date)
    
    active_result = await session.execute(active_users_query)
    active_ltv = active_result.scalar() or 0.0
    
    # LTV для возвращающихся пользователей
    returning_users_query = select(
        func.avg(
            select(func.sum(Transaction.amount))
            .where(Transaction.type == TRANSACTION_DEPOSIT)
            .where(Transaction.user_id == User.user_id)
            .scalar_subquery()
        )
    ).where(
        User.created_at < active_cutoff
    )
    if start_date:
        returning_users_query = returning_users_query.where(User.created_at >= start_date)
    if end_date:
        returning_users_query = returning_users_query.where(User.created_at <= end_date)
    
    returning_result = await session.execute(returning_users_query)
    returning_ltv = returning_result.scalar() or 0.0
    
    return {
        "new_users": new_ltv,
        "active_users": active_ltv,
        "returning_users": returning_ltv
    }
```

### 3. CAC (Cost per Acquisition) и ROI

**Файл: `utils/marketing.py`**

```python
async def get_cac_by_source(
    session: AsyncSession,
    costs: dict,
    start_date=None,
    end_date=None
) -> dict:
    """
    CAC по источникам (если известны затраты)
    
    costs: dict с затратами по источникам
    {
        'telegram': 10000,  # рублей или звёзд
        'instagram': 5000,
        ...
    }
    
    Возвращает:
    - cost: затраты на источник
    - users: количество привлеченных пользователей
    - cac: стоимость привлечения одного пользователя
    """
    users_by_source = await get_users_by_source(session, start_date, end_date)
    
    cac_data = {}
    for source, cost in costs.items():
        users = users_by_source.get(source, 0)
        cac = cost / users if users > 0 else 0.0
        
        cac_data[source] = {
            "cost": cost,
            "users": users,
            "cac": cac
        }
    
    return cac_data

async def get_roi_by_source(
    session: AsyncSession,
    costs: dict,
    start_date=None,
    end_date=None
) -> dict:
    """
    ROI по источникам
    
    ROI = (LTV - CAC) / CAC * 100
    """
    ltv_by_source = await get_ltv_by_source(session, start_date, end_date)
    cac_by_source = await get_cac_by_source(session, costs, start_date, end_date)
    
    roi_data = {}
    for source in costs.keys():
        ltv = ltv_by_source.get(source, {}).get('average_ltv', 0.0)
        cac = cac_by_source.get(source, {}).get('cac', 0.0)
        
        if cac > 0:
            roi = ((ltv - cac) / cac) * 100.0
        else:
            roi = 0.0
        
        roi_data[source] = {
            "ltv": ltv,
            "cac": cac,
            "roi": roi
        }
    
    return roi_data
```

### 4. Retention (Удержание)

**Файл: `utils/marketing.py`**

```python
async def get_retention_rate(
    session: AsyncSession,
    days: list[int] = [1, 3, 7, 14, 30],
    start_date=None,
    end_date=None
) -> dict:
    """
    Retention rate по дням
    
    Процент пользователей, вернувшихся через N дней
    """
    from datetime import timedelta
    
    retention_data = {}
    
    for day in days:
        cutoff_date = datetime.utcnow() - timedelta(days=day)
        
        # Пользователи, зарегистрированные до cutoff_date
        registered_query = select(func.count(func.distinct(User.user_id))).where(
            User.created_at <= cutoff_date
        )
        if start_date:
            registered_query = registered_query.where(User.created_at >= start_date)
        if end_date:
            registered_query = registered_query.where(User.created_at <= end_date)
        
        registered_result = await session.execute(registered_query)
        registered = registered_result.scalar() or 0
        
        # Пользователи с активностью после cutoff_date
        active_query = select(func.count(func.distinct(User.user_id))).where(
            or_(
                Transaction.created_at >= cutoff_date,
                Application.created_at >= cutoff_date
            )
        )
        if start_date:
            active_query = active_query.where(User.created_at >= start_date)
        if end_date:
            active_query = active_query.where(User.created_at <= end_date)
        
        active_result = await session.execute(active_query)
        active = active_result.scalar() or 0
        
        retention_rate = (active / registered * 100.0) if registered > 0 else 0.0
        retention_data[f"day_{day}"] = retention_rate
    
    return retention_data

async def get_retention_by_source(
    session: AsyncSession,
    days: int = 30,
    start_date=None,
    end_date=None
) -> dict:
    """Retention по источникам"""
    # Аналогично get_retention_rate, но с группировкой по источникам
    pass

async def get_churn_rate(
    session: AsyncSession,
    days: int = 30,
    start_date=None,
    end_date=None
) -> float:
    """
    Churn rate (процент ушедших)
    
    Процент пользователей, которые не возвращались более N дней
    """
    cutoff_date = datetime.utcnow() - timedelta(days=days)
    
    # Все пользователи
    total_query = select(func.count(User.user_id))
    if start_date:
        total_query = total_query.where(User.created_at >= start_date)
    if end_date:
        total_query = total_query.where(User.created_at <= end_date)
    total_result = await session.execute(total_query)
    total = total_result.scalar() or 0
    
    # Пользователи с активностью после cutoff_date
    active_query = select(func.count(func.distinct(User.user_id))).where(
        or_(
            Transaction.created_at >= cutoff_date,
            Application.created_at >= cutoff_date
        )
    )
    if start_date:
        active_query = active_query.where(User.created_at >= start_date)
    if end_date:
        active_query = active_query.where(User.created_at <= end_date)
    active_result = await session.execute(active_query)
    active = active_result.scalar() or 0
    
    churned = total - active
    churn_rate = (churned / total * 100.0) if total > 0 else 0.0
    
    return churn_rate
```

## Тестирование

1. Тестирование расчетов конверсии
2. Тестирование расчетов LTV
3. Тестирование расчетов CAC и ROI
4. Тестирование расчетов Retention
5. Проверка корректности с различными периодами

## Оценка времени

**5-6 часов**

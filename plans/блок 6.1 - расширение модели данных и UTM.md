# Блок 6.1: Расширение модели данных и отслеживание трафика

## Цель

Добавить возможность отслеживания источников трафика через UTM-параметры и расширить модель данных для хранения маркетинговой информации.

## Задачи

### 1. Расширение модели User

**Файл: `database/models.py`**

Добавить поля в модель `User`:
- `traffic_source` (String, nullable) - источник трафика (utm_source)
- `traffic_campaign` (String, nullable) - кампания (utm_campaign)
- `traffic_medium` (String, nullable) - медиум (utm_medium)
- `traffic_content` (String, nullable) - контент (utm_content)
- `traffic_term` (String, nullable) - ключевое слово (utm_term)
- `referrer_user_id` (Integer, nullable) - ID реферера (если есть)
- `first_action_at` (DateTime, nullable) - время первого действия (регистрация или первая заявка)
- `first_deposit_at` (DateTime, nullable) - время первого депозита
- `first_application_at` (DateTime, nullable) - время первой заявки

### 2. Создание модели TrafficSource

**Файл: `database/models.py`**

```python
class TrafficSource(Base):
    __tablename__ = "traffic_sources"
    
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    source: Mapped[str] = mapped_column(String(64))  # utm_source
    campaign: Mapped[str | None] = mapped_column(String(64), nullable=True)  # utm_campaign
    medium: Mapped[str | None] = mapped_column(String(64), nullable=True)  # utm_medium
    content: Mapped[str | None] = mapped_column(String(64), nullable=True)  # utm_content
    term: Mapped[str | None] = mapped_column(String(64), nullable=True)  # utm_term
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
```

### 3. Создание утилит для работы с трафиком

**Файл: `utils/traffic.py`** (новый)

```python
from urllib.parse import parse_qs, urlparse
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from database.models import User, TrafficSource

def parse_utm_params(text: str) -> dict:
    """
    Парсинг UTM-параметров из команды /start
    
    Поддерживаемые форматы:
    - /start utm_source=telegram&utm_campaign=promo
    - /start?utm_source=telegram&utm_campaign=promo
    - /start ref123 (простой реферальный код)
    """
    params = {}
    
    # Удаляем команду /start
    text = text.replace('/start', '').strip()
    if not text:
        return params
    
    # Если есть знак вопроса, парсим как URL
    if '?' in text or '&' in text or '=' in text:
        # Убираем знак вопроса если есть
        if text.startswith('?'):
            text = text[1:]
        
        # Парсим параметры
        pairs = text.split('&')
        for pair in pairs:
            if '=' in pair:
                key, value = pair.split('=', 1)
                key = key.strip().lower()
                if key.startswith('utm_'):
                    params[key[4:]] = value.strip()  # убираем префикс utm_
                elif key == 'ref':
                    params['source'] = f'ref_{value.strip()}'
    else:
        # Простой реферальный код
        params['source'] = f'ref_{text.strip()}'
    
    return params

def normalize_traffic_source(params: dict) -> dict:
    """
    Нормализация параметров источника трафика
    """
    normalized = {}
    
    # Основные параметры
    normalized['source'] = params.get('source', 'direct')
    normalized['campaign'] = params.get('campaign')
    normalized['medium'] = params.get('medium')
    normalized['content'] = params.get('content')
    normalized['term'] = params.get('term')
    
    # Нормализация source
    if normalized['source']:
        normalized['source'] = normalized['source'].lower().strip()
    
    return normalized

async def save_traffic_source(
    session: AsyncSession,
    user: User,
    params: dict
) -> None:
    """
    Сохранение источника трафика для пользователя
    """
    normalized = normalize_traffic_source(params)
    
    # Сохраняем в модель User
    user.traffic_source = normalized.get('source')
    user.traffic_campaign = normalized.get('campaign')
    user.traffic_medium = normalized.get('medium')
    user.traffic_content = normalized.get('content')
    user.traffic_term = normalized.get('term')
    
    await session.flush()
```

### 4. Модификация обработчика /start

**Файл: `handlers/user_handlers.py`**

```python
from utils.traffic import parse_utm_params, save_traffic_source

@router.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    """Обработчик команды /start"""
    await state.clear()
    
    # Парсинг UTM-параметров
    utm_params = parse_utm_params(message.text)
    
    async for session in get_session():
        # Проверяем, новый ли пользователь
        existing_user = await get_or_create_user(
            session,
            user_id=message.from_user.id,
            username=message.from_user.username,
            first_name=message.from_user.first_name,
            last_name=message.from_user.last_name,
        )
        
        # Сохраняем источник трафика только для новых пользователей
        is_new_user = existing_user.created_at == existing_user.created_at.replace(
            hour=0, minute=0, second=0, microsecond=0
        )
        
        if is_new_user and utm_params:
            await save_traffic_source(session, existing_user, utm_params)
            existing_user.first_action_at = datetime.utcnow()
        
        await session.commit()
    
    # Остальной код обработчика...
```

### 5. Обновление функции get_or_create_user

**Файл: `database/queries.py`**

Убедиться, что функция корректно работает с новыми полями.

### 6. Создание миграции БД

**Файл: `scripts/migrate_add_traffic_tracking.py`** (новый)

Скрипт для добавления новых полей в существующую таблицу users и создания таблицы traffic_sources.

## Тестирование

1. Тестирование парсинга различных форматов UTM:
   - `/start utm_source=telegram&utm_campaign=promo`
   - `/start?utm_source=instagram&utm_campaign=summer`
   - `/start ref123`
   - `/start` (без параметров)

2. Проверка сохранения данных в БД
3. Проверка, что данные сохраняются только для новых пользователей

## Оценка времени

**2-3 часа**

# Блок 6.2: Бизнес-показатели

## Цель

Реализовать сбор и расчет бизнес-показателей: финансовые метрики, статистика по заявкам и пользователям.

## Задачи

### 1. Финансовые показатели

**Файл: `database/queries.py`**

```python
# Общие финансовые показатели
async def get_total_revenue(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Общий доход (сумма всех депозитов)"""
    query = select(func.sum(Transaction.amount)).where(
        Transaction.type == TRANSACTION_DEPOSIT
    )
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0

async def get_total_deposits(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Количество депозитов"""
    query = select(func.count(Transaction.id)).where(
        Transaction.type == TRANSACTION_DEPOSIT
    )
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0

async def get_total_withdrawals(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Общая сумма списаний (заявки)"""
    query = select(func.sum(func.abs(Transaction.amount))).where(
        Transaction.type == TRANSACTION_WITHDRAWAL
    )
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0

async def get_net_revenue(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Чистая прибыль (доход - расходы)"""
    revenue = await get_total_revenue(session, start_date, end_date)
    withdrawals = await get_total_withdrawals(session, start_date, end_date)
    return revenue - withdrawals

# По периодам
async def get_revenue_by_period(session: AsyncSession, days: int) -> list[dict]:
    """Доход по дням за последние N дней"""
    # SQL запрос с группировкой по дням
    pass

async def get_revenue_by_source(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """Доход по источникам трафика"""
    query = select(
        User.traffic_source,
        func.sum(Transaction.amount).label('revenue')
    ).join(
        Transaction, User.user_id == Transaction.user_id
    ).where(
        Transaction.type == TRANSACTION_DEPOSIT
    )
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    query = query.group_by(User.traffic_source)
    
    result = await session.execute(query)
    return {row.traffic_source: row.revenue for row in result.all()}

# Топ показатели
async def get_top_deposits(session: AsyncSession, limit=10, start_date=None, end_date=None) -> list:
    """Топ депозитов"""
    query = select(Transaction).where(
        Transaction.type == TRANSACTION_DEPOSIT
    ).order_by(Transaction.amount.desc()).limit(limit)
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    result = await session.execute(query)
    return result.scalars().all()

async def get_average_deposit_amount(session: AsyncSession, start_date=None, end_date=None) -> float:
    """Средний размер депозита"""
    query = select(func.avg(Transaction.amount)).where(
        Transaction.type == TRANSACTION_DEPOSIT
    )
    if start_date:
        query = query.where(Transaction.created_at >= start_date)
    if end_date:
        query = query.where(Transaction.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0.0
```

### 2. Показатели по заявкам

**Файл: `database/queries.py`**

```python
# Общие показатели
async def get_total_applications(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Общее количество заявок"""
    query = select(func.count(Application.id))
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0

async def get_applications_by_status(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """Заявки по статусам"""
    query = select(
        Application.status,
        func.count(Application.id).label('count')
    )
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    query = query.group_by(Application.status)
    
    result = await session.execute(query)
    return {row.status: row.count for row in result.all()}

async def get_application_success_rate(session: AsyncSession, start_date=None, end_date=None) -> float:
    """Процент успешных заявок"""
    total = await get_total_applications(session, start_date, end_date)
    if total == 0:
        return 0.0
    
    query = select(func.count(Application.id)).where(
        Application.status == STATUS_COMPLETED
    )
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    result = await session.execute(query)
    completed = result.scalar() or 0
    
    return (completed / total) * 100.0

# Эффективность
async def get_average_processing_time(session: AsyncSession, start_date=None, end_date=None) -> float:
    """Среднее время обработки заявки (в секундах)"""
    query = select(
        func.avg(
            func.cast(
                (Application.completed_at - Application.started_at),
                Integer
            )
        )
    ).where(
        Application.status == STATUS_COMPLETED,
        Application.started_at.isnot(None),
        Application.completed_at.isnot(None)
    )
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    
    result = await session.execute(query)
    seconds = result.scalar()
    return seconds.total_seconds() if seconds else 0.0

async def get_average_queue_time(session: AsyncSession, start_date=None, end_date=None) -> float:
    """Среднее время в очереди (в секундах)"""
    query = select(
        func.avg(
            func.cast(
                (Application.started_at - Application.created_at),
                Integer
            )
        )
    ).where(
        Application.started_at.isnot(None)
    )
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    
    result = await session.execute(query)
    seconds = result.scalar()
    return seconds.total_seconds() if seconds else 0.0

async def get_applications_per_user(session: AsyncSession, start_date=None, end_date=None) -> float:
    """Среднее количество заявок на пользователя"""
    total_apps = await get_total_applications(session, start_date, end_date)
    if total_apps == 0:
        return 0.0
    
    query = select(func.count(func.distinct(Application.user_id)))
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    result = await session.execute(query)
    unique_users = result.scalar() or 1
    
    return total_apps / unique_users

# По источникам трафика
async def get_applications_by_source(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """Заявки по источникам трафика"""
    query = select(
        User.traffic_source,
        func.count(Application.id).label('count')
    ).join(
        Application, User.user_id == Application.user_id
    )
    if start_date:
        query = query.where(Application.created_at >= start_date)
    if end_date:
        query = query.where(Application.created_at <= end_date)
    query = query.group_by(User.traffic_source)
    
    result = await session.execute(query)
    return {row.traffic_source or 'unknown': row.count for row in result.all()}
```

### 3. Показатели по пользователям

**Файл: `database/queries.py`**

```python
# Общие показатели
async def get_total_users(session: AsyncSession, start_date=None, end_date=None) -> int:
    """Общее количество пользователей"""
    query = select(func.count(User.user_id))
    if start_date:
        query = query.where(User.created_at >= start_date)
    if end_date:
        query = query.where(User.created_at <= end_date)
    result = await session.execute(query)
    return result.scalar() or 0

async def get_new_users_by_period(session: AsyncSession, days: int) -> list[dict]:
    """Новые пользователи по дням"""
    # SQL запрос с группировкой по дням
    pass

async def get_active_users(session: AsyncSession, days=30) -> int:
    """Активные пользователи (с активностью за последние N дней)"""
    cutoff_date = datetime.utcnow() - timedelta(days=days)
    
    # Пользователи с транзакциями или заявками
    query = select(func.count(func.distinct(User.user_id))).where(
        or_(
            Transaction.created_at >= cutoff_date,
            Application.created_at >= cutoff_date
        )
    )
    result = await session.execute(query)
    return result.scalar() or 0

async def get_users_by_role(session: AsyncSession) -> dict:
    """Распределение пользователей по ролям"""
    query = select(
        User.role,
        func.count(User.user_id).label('count')
    ).group_by(User.role)
    
    result = await session.execute(query)
    return {row.role: row.count for row in result.all()}

# По источникам трафика
async def get_users_by_source(session: AsyncSession, start_date=None, end_date=None) -> dict:
    """Пользователи по источникам трафика"""
    query = select(
        User.traffic_source,
        func.count(User.user_id).label('count')
    )
    if start_date:
        query = query.where(User.created_at >= start_date)
    if end_date:
        query = query.where(User.created_at <= end_date)
    query = query.group_by(User.traffic_source)
    
    result = await session.execute(query)
    return {row.traffic_source or 'unknown': row.count for row in result.all()}
```

### 4. Функции агрегации

**Файл: `utils/statistics.py`**

```python
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from database.queries import (
    get_total_revenue, get_total_deposits, get_total_withdrawals,
    get_net_revenue, get_total_applications, get_applications_by_status,
    get_application_success_rate, get_total_users, get_users_by_role,
    # ... другие функции
)

class StatisticsPeriod:
    """Класс для работы с периодами статистики"""
    ALL_TIME = "all_time"
    LAST_30_DAYS = "30_days"
    LAST_7_DAYS = "7_days"
    TODAY = "today"
    CUSTOM = "custom"

def get_date_range(period: str, custom_start=None, custom_end=None) -> tuple[Optional[datetime], Optional[datetime]]:
    """Получить диапазон дат для периода"""
    now = datetime.utcnow()
    if period == StatisticsPeriod.TODAY:
        start = datetime(now.year, now.month, now.day)
        return start, now
    elif period == StatisticsPeriod.LAST_7_DAYS:
        return now - timedelta(days=7), now
    elif period == StatisticsPeriod.LAST_30_DAYS:
        return now - timedelta(days=30), now
    elif period == StatisticsPeriod.CUSTOM:
        return custom_start, custom_end
    else:  # ALL_TIME
        return None, None

async def get_financial_stats(session: AsyncSession, period: str = StatisticsPeriod.ALL_TIME) -> dict:
    """Получить финансовую статистику"""
    start_date, end_date = get_date_range(period)
    
    total_revenue = await get_total_revenue(session, start_date, end_date)
    total_deposits = await get_total_deposits(session, start_date, end_date)
    total_withdrawals = await get_total_withdrawals(session, start_date, end_date)
    net_revenue = await get_net_revenue(session, start_date, end_date)
    
    return {
        "total_revenue": total_revenue,
        "total_deposits": total_deposits,
        "total_withdrawals": total_withdrawals,
        "net_revenue": net_revenue,
        "period": period,
        "start_date": start_date,
        "end_date": end_date
    }

async def get_applications_stats(session: AsyncSession, period: str = StatisticsPeriod.ALL_TIME) -> dict:
    """Получить статистику по заявкам"""
    start_date, end_date = get_date_range(period)
    
    total = await get_total_applications(session, start_date, end_date)
    by_status = await get_applications_by_status(session, start_date, end_date)
    success_rate = await get_application_success_rate(session, start_date, end_date)
    avg_processing_time = await get_average_processing_time(session, start_date, end_date)
    avg_queue_time = await get_average_queue_time(session, start_date, end_date)
    
    return {
        "total": total,
        "by_status": by_status,
        "success_rate": success_rate,
        "average_processing_time": avg_processing_time,
        "average_queue_time": avg_queue_time,
        "period": period
    }

async def get_users_stats(session: AsyncSession, period: str = StatisticsPeriod.ALL_TIME) -> dict:
    """Получить статистику по пользователям"""
    start_date, end_date = get_date_range(period)
    
    total = await get_total_users(session, start_date, end_date)
    active = await get_active_users(session, days=30)
    by_role = await get_users_by_role(session)
    
    return {
        "total": total,
        "active": active,
        "by_role": by_role,
        "period": period
    }
```

## Тестирование

1. Тестирование всех SQL запросов
2. Проверка корректности расчетов
3. Тестирование с различными периодами
4. Проверка производительности запросов

## Оценка времени

**4-5 часов**
